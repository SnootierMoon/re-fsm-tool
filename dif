diff --git a/src/app.js b/src/app.js
index 343e302..13b7996 100644
--- a/src/app.js
+++ b/src/app.js
@@ -82,4 +82,4 @@ function onUserInput() {
 }
 
 
-input.addEventListener("keyup", onUserInput);
+input.addEventListener("input", onUserInput);
diff --git a/src/re_fsm.zig b/src/re_fsm.zig
index 0dbde8a..5c520a2 100644
--- a/src/re_fsm.zig
+++ b/src/re_fsm.zig
@@ -437,7 +437,7 @@ pub const Nfa = struct {
         var deltas = std.ArrayList(Delta).init(gpa);
         defer deltas.deinit();
 
-        const StateInfo = struct { n_states: usize, state0: usize, n_finals: usize, final0: usize };
+        const StateInfo = struct { n_states: usize, n_finals: usize, state_idx: std.ArrayListUnmanaged(struct { istate0: usize, fstate0: usize }) };
         var infos = try arena.alloc(StateInfo, ast.nodes.len);
 
         const slice = ast.nodes.slice();
@@ -448,83 +448,107 @@ pub const Nfa = struct {
                 .epsilon => {
                     infos[idx].n_states = 2;
                     infos[idx].n_finals = 1;
+                    infos[idx].state_idx = .{};
                 },
                 .mask => {
                     infos[idx].n_states = 2;
                     infos[idx].n_finals = 1;
+                    infos[idx].state_idx = .{};
                 },
                 .either => {
                     const lhs_idx = data[idx].either;
                     infos[idx].n_states = 1 + infos[lhs_idx].n_states + infos[idx-1].n_states;
                     infos[idx].n_finals = infos[lhs_idx].n_finals + infos[idx-1].n_finals;
+                    infos[idx].state_idx = .{};
                 },
                 .concat => {
                     const lhs_idx = data[idx].concat;
                     infos[idx].n_states = infos[lhs_idx].n_states + infos[idx-1].n_states;
                     infos[idx].n_finals = infos[idx-1].n_finals;
+                    infos[idx].state_idx = .{};
                 },
                 .look_around => return error.Unimplemented,
                 .repeat => {
                     infos[idx].n_states = infos[idx-1].n_states;
                     infos[idx].n_finals = infos[idx-1].n_finals;
+                    infos[idx].state_idx = .{};
                 },
             }
         }
-        infos[ast.nodes.len - 1].state0 = 0;
-        infos[ast.nodes.len - 1].final0 = infos[ast.nodes.len - 1].n_states - infos[ast.nodes.len - 1].n_finals;
+        try infos[ast.nodes.len - 1].state_idx.append(arena, .{ 
+            .istate0 = 0, 
+            .fstate0 = infos[ast.nodes.len - 1].n_states - infos[ast.nodes.len - 1].n_finals,
+        });
         for (0..ast.nodes.len) |i| {
             const idx = ast.nodes.len - i - 1;
             switch (tags[idx]) {
                 .epsilon, .mask => {},
                 .either => {
                     const lhs_idx = data[idx].either;
-                    infos[lhs_idx].state0 = infos[idx].state0 + 1;
-                    infos[lhs_idx].final0 = infos[idx].final0;
-                    infos[idx - 1].state0 = infos[idx].state0 + infos[lhs_idx].n_states + 1;
-                    infos[idx - 1].final0 = infos[idx].final0 + infos[lhs_idx].n_finals;
+                    for (infos[idx].state_idx.items) |state_idx| {
+                        try infos[lhs_idx].state_idx.append(arena, .{
+                            .istate0 = state_idx.istate0 + 1,
+                            .fstate0 = state_idx.fstate0,
+                        });
+                        try infos[idx - 1].state_idx.append(arena, .{
+                            .istate0 = state_idx.istate0 +  infos[lhs_idx].n_states - infos[lhs_idx].n_finals + 1,
+                            .fstate0 = state_idx.fstate0 + infos[lhs_idx].n_finals,
+                        });
+                    }
                 },
                 .concat => {
                     const lhs_idx = data[idx].concat;
-                    infos[lhs_idx].state0 = infos[idx].state0;
-                    infos[lhs_idx].final0 = infos[idx].state0 + infos[lhs_idx].n_states - infos[lhs_idx].n_finals;
-                    infos[idx - 1].state0 = infos[idx].state0 + infos[lhs_idx].n_states;
-                    infos[idx - 1].final0 = infos[idx].final0;
+                    for (infos[idx].state_idx.items) |state_idx| {
+                        try infos[lhs_idx].state_idx.append(arena, .{
+                            .istate0 = state_idx.istate0,
+                            .fstate0 = state_idx.istate0 + infos[lhs_idx].n_states - infos[lhs_idx].n_finals,
+                        });
+                        try infos[idx - 1].state_idx.append(arena, .{
+                            .istate0 = state_idx.istate0 + infos[lhs_idx].n_states,
+                            .fstate0 = state_idx.fstate0,
+                        });
+                    }
                 },
                 .look_around => return error.Unimplemented,
                 .repeat => {
-                    infos[idx - 1].state0 = infos[idx].state0;
-                    infos[idx - 1].final0 = infos[idx].final0;
+                    for (infos[idx].state_idx.items) |state_idx| {
+                        try infos[idx - 1].state_idx.append(arena, .{
+                            .istate0 = state_idx.istate0,
+                            .fstate0 = state_idx.fstate0,
+                        });
+                    }
                 },
             }
+            std.log.info("{}\n", .{infos[idx]});
         }
 
         for (0..ast.nodes.len) |idx| {
             switch (tags[idx]) {
                 .epsilon => {
-                    try deltas.append(.{ .from = infos[idx].state0, .sym = null, .to = infos[idx].final0 });
+                    try deltas.append(.{ .from = state_idx.istate0, .sym = null, .to = state_idx.final0 });
                 },
                 .mask => {
                     for (0..127) |i| {
                         if (data[idx].mask & (@as(u127, 1) << @intCast(i)) != 0) {
-                            try deltas.append(.{ .from = infos[idx].state0, .sym = @intCast(i), .to = infos[idx].final0 });
+                            try deltas.append(.{ .from = state_idx.istate0, .sym = @intCast(i), .to = state_idx.final0 });
                         }
                     }
                 },
                 .either => {
                     const lhs_idx = data[idx].either;
-                    try deltas.append(.{ .from = infos[idx].state0, .sym = null, .to = infos[lhs_idx].state0 });
-                    try deltas.append(.{ .from = infos[idx].state0, .sym = null, .to = infos[idx - 1].state0 });
+                    try deltas.append(.{ .from = infos[idx].istate0, .sym = null, .to = infos[lhs_idx].istate0 });
+                    try deltas.append(.{ .from = infos[idx].istate0, .sym = null, .to = infos[idx - 1].istate0 });
                 },
                 .concat => {
                     const lhs_idx = data[idx].concat;
                     for (0..infos[lhs_idx].n_finals) |i| {
-                        try deltas.append(.{ .from = infos[lhs_idx].final0 + i, .sym = null, .to = infos[idx - 1].state0 });
+                        try deltas.append(.{ .from = infos[lhs_idx].final0 + i, .sym = null, .to = infos[idx - 1].istate0 });
                     }
                 },
                 .look_around => return error.Unimplemented,
                 .repeat => {
                     for (0..infos[idx - 1].n_finals) |i| {
-                        try deltas.append(.{ .from = infos[idx - 1].final0 + i, .sym = null, .to = infos[idx - 1].state0 });
+                        try deltas.append(.{ .from = infos[idx - 1].final0 + i, .sym = null, .to = infos[idx - 1].istate0 });
                     }
                 }
             }
@@ -540,4 +564,24 @@ pub const Nfa = struct {
     pub fn deinit(nfa: *Nfa, gpa: std.mem.Allocator) void {
         gpa.free(nfa.deltas);
     }
+
+    pub fn viz(nfa: Nfa, writer: anytype) !void {
+        try writer.print("digraph {{", .{});
+        try writer.print(" node [shape=circle]", .{});
+        for (0..nfa.final0) |i| {
+            try writer.print(" {}\n", .{i});
+        }
+        try writer.print(" node [shape=rect]", .{});
+        for (nfa.final0..nfa.states) |i| {
+            try writer.print(" {}\n", .{i});
+        }
+        for (nfa.deltas) |delta| {
+            if (delta.sym) |sym| {
+                try writer.print(" {} -> {} [label=\"{c}\"]", .{ delta.from, delta.to, sym });
+            } else {
+                try writer.print(" {} -> {}", .{ delta.from, delta.to });
+            }
+        }
+        try writer.print(" }}", .{});
+    }
 };
diff --git a/src/wasm_root.zig b/src/wasm_root.zig
index 1b5ec75..44cf31d 100644
--- a/src/wasm_root.zig
+++ b/src/wasm_root.zig
@@ -32,11 +32,12 @@ fn run() !void {
     defer ast.deinit(std.heap.wasm_allocator);
 
     output_digraph.clearRetainingCapacity();
-    try ast.viz(output_digraph.writer());
+    // try ast.viz(output_digraph.writer());
 
     var nfa = try Nfa.init(std.heap.wasm_allocator, ast);
     defer nfa.deinit(std.heap.wasm_allocator);
     
+    try nfa.viz(output_digraph.writer());
     std.log.info("{any}\n", .{nfa});
 }
 
